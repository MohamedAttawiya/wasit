# Wasit Lambda Auth: JWT Principal + Group/Grant Authorization

All API Lambdas that require user auth must sit behind **API Gateway HTTP API (v2)** with a **JWT Authorizer** configured against the Wasit Cognito User Pool. The authorizer injects verified JWT claims into `event.requestContext.authorizer.jwt.claims` (HTTP API v2 shape). In your handler, extract the caller identity via `getPrincipal(event)` from `@wasit/authz`, which normalizes `sub` (principal userId), `email`, and `cognito:groups` into a stable `Principal`. If `sub` is missing, treat the request as unauthenticated and return 401 (the library throws `AuthzError` with `toHttpErrorResponse` for consistent JSON errors).

For coarse authorization, enforce role-group access using `requireGroup(principal, "PlatformAdmin" | "InternalOps" | "Seller")` (roles are exclusive Cognito groups enforced by the control-plane Lambda). This is the default model for most endpoints: authenticate → parse principal → enforce group(s) → proceed. Example: `const p = getPrincipal(event); requireGroup(p, "Seller");` then run the business logic. Do not re-implement role parsing in the UI; Lambdas are authoritative.

For fine-grained authorization (only when needed), import from `@wasit/authz/grants` to opt into DynamoDB-backed checks (this intentionally pulls AWS SDK only for Lambdas that need it). Use `requireStoreOwner(p, storeId, { tableName: process.env.AUTHZ_GRANTS_TABLE! })` or `hasGrant(p, skPrefix, { tableName })` where the grants table uses `pk = PRINCIPAL#USER#<sub>` and `sk` prefixes like `RESOURCE#STORE#<storeId>#PERM#OWNER`. Always keep `"PlatformAdmin"` as an override for privileged access paths, and keep all enforcement server-side in Lambda.
